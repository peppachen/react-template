### 父子组件(Props)

#### 1. 子组件向父组件传递数据

- 使用回调函数（props 传递一个函数）。

- 子组件内部调用该函数，将数据传递给父组件。

#### 2. 父组件向子组件传递数据

- 使用 props。

- 子组件通过解构 props 获取父组件传递的参数。

####  3. 状态管理

- 父组件控制全局状态，子组件可以通过父组件的回调函数修改父组件的状态，从而实现父子通信。

```tsx
import React, { useState } from 'react';
import { Button, Input, Card } from 'antd';

// 子组件
interface ChildProps {
  message: string; // 父组件传递的参数
  onMessageUpdate: (newMessage: string) => void; // 父组件传递的回调函数
}

const ChildComponent: React.FC<ChildProps> = ({ message, onMessageUpdate }) => {
  const [inputValue, setInputValue] = useState('');

  const handleUpdate = () => {
    if (inputValue.trim()) {
      onMessageUpdate(inputValue); // 调用父组件传递的回调函数
      setInputValue(''); // 清空输入框
    }
  };

  return (
    <Card title="子组件">
      <p>接收到的父组件消息: {message}</p>
      <Input
        placeholder="输入新的消息"
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
        style={{ marginBottom: '10px' }}
      />
      <Button type="primary" onClick={handleUpdate}>
        更新消息
      </Button>
    </Card>
  );
};

// 父组件
const ParentComponent: React.FC = () => {
  const [message, setMessage] = useState('Hello from Parent!');

  const handleMessageUpdate = (newMessage: string) => {
    setMessage(newMessage); // 更新父组件的消息
  };

  return (
    <div>
      <Card title="父组件" style={{ marginBottom: '20px' }}>
        <p>当前消息: {message}</p>
      </Card>
      <ChildComponent message={message} onMessageUpdate={handleMessageUpdate} />
    </div>
  );
};

export default ParentComponent;
```

### 跨层级组件数据传递

#### 1. useContext

- 适合深层次的跨层级数据传递，避免 Props Drilling，组件解耦明显。

```tsx
import React, { createContext, useContext, useState } from 'react';
import { Button, Card } from 'antd';

// 1. 创建 Context
const MessageContext = createContext<{
  message: string;
  updateMessage: (newMessage: string) => void;
} | null>(null);

// 2. 子组件
const ChildComponent: React.FC = () => {
  const context = useContext(MessageContext); // 使用 Context 获取数据

  if (!context) {
    return <p>没有可用的上下文数据</p>;
  }

  const { message, updateMessage } = context;

  return (
    <Card title="子组件">
      <p>当前消息: {message}</p>
      <Button
        type="primary"
        onClick={() => updateMessage('来自子组件的新消息')}
      >
        更新消息
      </Button>
    </Card>
  );
};

// 3. 中间组件
const MiddleComponent: React.FC = () => {
  return (
    <div>
      <Card title="中间组件">
        <p>这是中间组件</p>
        <ChildComponent />
      </Card>
    </div>
  );
};

// 4. 父组件
const ParentComponent: React.FC = () => {
  const [message, setMessage] = useState('来自父组件的初始消息');

  const updateMessage = (newMessage: string) => {
    setMessage(newMessage);
  };

  return (
    <MessageContext.Provider value={{ message, updateMessage }}>
      <Card title="父组件" style={{ marginBottom: '20px' }}>
        <p>父组件控制的消息: {message}</p>
      </Card>
      <MiddleComponent />
    </MessageContext.Provider>
  );
};

export default ParentComponent;
```

#### 2. 自定义hooks

- 封装逻辑，代码更简洁、复用性更强，错误处理更加集中。

```tsx
import React, { useState, createContext, useContext } from 'react';
import { Button, Card } from 'antd';

// 1. 创建 Context
const MessageContext = createContext<{
  message: string;
  updateMessage: (newMessage: string) => void;
} | null>(null);

// 2. 自定义 Hook
const useMessage = () => {
  const context = useContext(MessageContext);
  if (!context) {
    throw new Error('useMessage 必须在 MessageContext.Provider 内使用');
  }
  return context;
};

// 3. 子组件
const ChildComponent: React.FC = () => {
  const { message, updateMessage } = useMessage();

  return (
    <Card title="子组件">
      <p>当前消息: {message}</p>
      <Button
        type="primary"
        onClick={() => updateMessage('来自子组件的新消息')}
      >
        更新消息
      </Button>
    </Card>
  );
};

// 4. 父组件
const ParentComponent: React.FC = () => {
  const [message, setMessage] = useState('来自父组件的初始消息');

  const updateMessage = (newMessage: string) => {
    setMessage(newMessage);
  };

  return (
    <MessageContext.Provider value={{ message, updateMessage }}>
      <Card title="父组件" style={{ marginBottom: '20px' }}>
        <p>父组件控制的消息: {message}</p>
      </Card>
      <ChildComponent />
    </MessageContext.Provider>
  );
};

export default ParentComponent;
```

#### 3. Redux等状态管理工具

- 适合复杂的全局状态管理，数据流清晰，工具链丰富（如 DevTools 调试）。

#### 4. 通过props层层传递

- 简单直接，适合浅层级的组件通信，无需额外工具。